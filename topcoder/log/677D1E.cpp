#include <bits/stdc++.h>
using namespace std;

#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)
#define pb push_back
#define all(x) (x).begin(), (x).end()
template<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }
template<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }
template <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << "(" << v.first << ", " << v.second << ")"; return o; }
template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { if (!v.empty()) { o << '['; copy(v.begin(), v.end(), ostream_iterator<T>(o, ", ")); o << "\b\b]"; } return o; }
using ll = long long; using ld = long double; using vll = vector<ll>; using vld = vector<ld>;
typedef pair<ll, ll> P;

static const double EPS = 1e-14;
static const long long INF = 1e18;
#define MAX_N 100005

class DoubleOrOneEasy {
    public:
        int minimalSteps(int a, int b, int newA, int newB) {
            int diff = b - a; 
            int newdiff = newB - newA; 
            if (newA - a < 0) return -1;
            if (newB - b < 0) return -1;
            int m;
            if (diff != 0) {
                if (newdiff % diff) return -1;
                if (__builtin_popcount(newdiff / diff) != 1) return -1;
                m = round(log2(newdiff / diff));
            } else {
                if (newdiff) return -1;
                m = log2(newA / a);
            }

            int r = newA - a * (1ll << m);
            if (r < 0) return -1;
            int p = 0;
            for (int i = m; i >= 0; i--) {
                p += r / (1ll << i);
                r -= r / (1ll << i) * (1ll << i);
            }
            return m + p;
        }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, int p3, bool hasAnswer, int p4) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3;
	cout << "]" << endl;
	DoubleOrOneEasy *obj;
	int answer;
	obj = new DoubleOrOneEasy();
	clock_t startTime = clock();
	answer = obj->minimalSteps(p0, p1, p2, p3);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p4 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p4;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	int p0;
	int p1;
	int p2;
	int p3;
	int p4;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 100;
	p1 = 1000;
	p2 = 101;
	p3 = 1001;
	p4 = 1;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 100;
	p1 = 1000;
	p2 = 202;
	p3 = 2002;
	p4 = 2;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 2;
	p1 = 2;
	p2 = 1;
	p3 = 1;
	p4 = -1;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 1;
	p1 = 111111111;
	p2 = 8;
	p3 = 888888888;
	p4 = 3;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = 1;
	p1 = 111111111;
	p2 = 9;
	p3 = 999999999;
	p4 = -1;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = 100;
	p1 = 100;
	p2 = 800;
	p3 = 800;
	p4 = 3;
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 6 -----
    disabled = false;
    p0 = 100;
    p1 = 100;
    p2 = 816;
    p3 = 816;
    p4 = 5;
    all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, p3, true, p4) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    if (all_right) {
        if (tests_disabled) {
            cout << "You're a stud (but some test cases were disabled)!" << endl;
        } else {
            cout << "You're a stud (at least on given cases)!" << endl;
        }
    } else {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
// You have two positive integers: the first one is a, the second one is b.
// 
// You also have a red button and a blue button.
// Whenever you push the red button, both your numbers are incremented by 1.
// Whenever you push the blue button, both your numbers are multiplied by 2.
// 
// Your goal is to change the pair (a, b) into the pair (newA, newB).
// 
// You are given the ints a, b, newA, and newB.
// If there is a sequence of zero or more button pushes that accomplishes your goal, return the length of the shortest such sequence.
// Otherwise, return -1.
// 
// DEFINITION
// Class:DoubleOrOneEasy
// Method:minimalSteps
// Parameters:int, int, int, int
// Returns:int
// Method signature:int minimalSteps(int a, int b, int newA, int newB)
// 
// 
// NOTES
// -The operations can produce arbitrarily large integers. For example, if you just push the blue button 1000 times in a row, you will get the numbers a*2^1000 and b*2^1000.
// 
// 
// CONSTRAINTS
// -a will be between 1 and 1,000,000,000, inclusive.
// -b will be between 1 and 1,000,000,000, inclusive.
// -newA will be between 1 and 1,000,000,000, inclusive.
// -newB will be between 1 and 1,000,000,000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 100
// 1000
// 101
// 1001
// 
// Returns: 1
// 
// Just push the red button once.
// 
// 1)
// 100
// 1000
// 202
// 2002
// 
// Returns: 2
// 
// The best solution is to push the red button followed by the blue button.
// This performs the operation +1 followed by the operation *2.
// 
// Another valid solution is to push the blue button once and then the red button twice to perform the operations *2, +1, and +1.
// This solution is not optimal because the previous solution contains fewer operations.
// 
// 2)
// 2
// 2
// 1
// 1
// 
// Returns: -1
// 
// We are unable to decrease a and b.
// 
// 3)
// 1
// 111111111
// 8
// 888888888
// 
// Returns: 3
// 
// 
// 
// 4)
// 1
// 111111111
// 9
// 999999999
// 
// Returns: -1
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
