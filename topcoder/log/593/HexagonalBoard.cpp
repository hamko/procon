#include <bits/stdc++.h>
using namespace std;

#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define mt make_tuple
template<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }
template<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

using ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; 
using vi = vector<int>; using vvi = vector<vi>;
using P = pair<ll, ll>;

template <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << "(" << v.first << ", " << v.second << ")"; return o; }
template<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};
template<class Ch, class Tr, class Tuple, size_t... Is>
void print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? "" : ", ") << get<Is>(t)), 0)...}; }
template<class Ch, class Tr, class... Args> 
auto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << "("; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << ")"; }
ostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << " "; cout << endl; } return o; }
template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? ", " : ""); o << "]";  return o; }
template <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? ", " : ""); o << "]";  return o; }
template <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? ", " : ""); o << "]";  return o; }
template <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << "]";  return o; }

static const double EPS = 1e-14;
static const long long INF = 1e18;
static const long long mo = 1e9+7;

class HexagonalBoard {
    public:
        int minColors(vector <string> b) {
            ll n = b.size();
            auto b_org = b;
            vll di = {-1, -1, 0, 0, 1, 1};
            vll dj = {0, +1, -1, +1, -1, 0};

            ll counter = 0;
            rep(i_, n) rep(j_, n) if (b[i_][j_] == 'X') 
                counter++;
            if (!counter)
                return 0;

            rep(i_, n) rep(j_, n) if (b[i_][j_] == 'X') {
                rep(d, 6) {
                    ll i = i_ + di[d], j = j_ + dj[d];
                    if (!(i < 0 || j < 0 || i >= n || j >= n) && b[i][j] == 'X') {
                        goto not_one;
                    }
                }
            }
            return 1;
            not_one:;

            while (1) {
                ll xnum = 0;
                ll si, sj;
                rep(i, n) rep(j, n) if (b[i][j] == 'X') {
                    xnum++;
                    si = i; 
                    sj = j;
                }
                if (!xnum)
                    break;

                b[si][sj] = 'A';
                function<void(ll, ll)> f = [&](ll i_, ll j_) { 
                    ll c = b[i_][j_] == 'A' ? 'B' : 'A';
                    rep(d, 6) {
                        ll i = i_ + di[d], j = j_ + dj[d];
                        if (i < 0 || j < 0 || i >= n || j >= n || b[i][j] != 'X')
                            continue;
                        b[i][j] = c;
                        f(i, j);
                    }
                };
                f(si, sj);
            }

            rep(i_, n) rep(j_, n) if (b[i_][j_] != '-') {
                rep(d, 6) {
                    ll i = i_ + di[d], j = j_ + dj[d];
                    if (i < 0 || j < 0 || i >= n || j >= n)
                        continue;
                    if (b[i_][j_] == b[i][j]) {
                        return 3;
                    }
                }
            }

            return 2;
        }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i) {
        if (i > 0) {
            cout << ",";
        }
        cout << "\"" << p0[i] << "\"";
    }
    cout << "}";
    cout << "]" << endl;
    HexagonalBoard *obj;
    int answer;
    obj = new HexagonalBoard();
    clock_t startTime = clock();
    answer = obj->minColors(p0);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer) {
        cout << "Desired answer:" << endl;
        cout << "\t" << p1 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer) {
        res = answer == p1;
    }
    if (!res) {
        cout << "DOESN'T MATCH!!!!" << endl;
    } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
        cout << "FAIL the timeout" << endl;
        res = false;
    } else if (hasAnswer) {
        cout << "Match :-)" << endl;
    } else {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main() {
    bool all_right;
    bool disabled;
    bool tests_disabled;
    all_right = true;
    tests_disabled = false;

    vector <string> p0;
    int p1;

    // ----- test 0 -----
    disabled = false;
    p0 = {"---","---","---"};
    p1 = 0;
    all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 1 -----
    disabled = false;
    p0 = {"-X--","---X","----","-X--"};
    p1 = 1;
    all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 2 -----
    disabled = false;
    p0 = {"XXXX","---X","---X","---X"};
    p1 = 2;
    all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 3 -----
    disabled = false;
    p0 = {"XX-XX--","-XX-XXX","X-XX--X","X--X-X-","XX-X-XX","-X-XX-X","-XX-XX-"};
    p1 = 3;
    all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------
  
    // ----- test 3 -----
    disabled = false;
    p0 = {"XX-X---","-XX--XX","X-X---X","---X-X-","XX---XX","-X-XX-X","-XX-XX-"};
    p1 = 2;
    all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------


    if (all_right) {
        if (tests_disabled) {
            cout << "You're a stud (but some test cases were disabled)!" << endl;
        } else {
            cout << "You're a stud (at least on given cases)!" << endl;
        }
    } else {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
// The pony Applejack has an N by N hexagonal board. The following picture shows the hexagonal board when N = 1, 2, 3, and 4.
// 
// 
// 
// 
// 
// She wants to color some cells of the board. You are given a vector <string> board. If the j-th character of the i-th element of board is 'X', she wants to color the cell (i, j). If she colors two cells that share an edge, she must use different colors for those cells. Return the minimal number of colors she needs.
// 
// DEFINITION
// Class:HexagonalBoard
// Method:minColors
// Parameters:vector <string>
// Returns:int
// Method signature:int minColors(vector <string> board)
// 
// 
// CONSTRAINTS
// -board will contain between 1 and 50 elements, inclusive.
// -Each element of board will contain exactly N characters, where N is the number of elements in board.
// -Each character in board will be either 'X' or '-'.
// 
// 
// EXAMPLES
// 
// 0)
// {"---",
//  "---",
//  "---"}
//  
// 
// Returns: 0
// 
// She won't color any cells, so she won't need any colors.
// 
// 1)
// {"-X--",
//  "---X",
//  "----",
//  "-X--"}
// 
// Returns: 1
// 
// She can color all cells with the same color.
// 
// 2)
// {"XXXX",
//  "---X",
//  "---X",
//  "---X"}
// 
// Returns: 2
// 
// For example, she can color cells in the following way:
// 
// Color cells (0, 0), (0, 2), (1, 3), and (3, 3) red.
// Color cells (0, 1), (0, 3), and (2, 3) blue.
// 
// 
// 
// 3)
// {"XX-XX--"
// ,"-XX-XXX"
// ,"X-XX--X"
// ,"X--X-X-"
// ,"XX-X-XX"
// ,"-X-XX-X"
// ,"-XX-XX-"}
// 
// Returns: 3
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
