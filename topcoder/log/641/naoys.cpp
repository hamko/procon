#include <bits/stdc++.h>
using namespace std;

#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define mt make_tuple
template<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }
template<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

using ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; 
using vi = vector<int>; using vvi = vector<vi>;
using P = pair<ll, ll>;

template <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << "(" << v.first << ", " << v.second << ")"; return o; }
template<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};
template<class Ch, class Tr, class Tuple, size_t... Is>
void print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? "" : ", ") << get<Is>(t)), 0)...}; }
template<class Ch, class Tr, class... Args> 
auto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << "("; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << ")"; }
ostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << " "; cout << endl; } return o; }
template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? ", " : ""); o << "]";  return o; }
template <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? ", " : ""); o << "]";  return o; }
template <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? ", " : ""); o << "]";  return o; }
template <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << "]";  return o; }

static const double EPS = 1e-14;
static const long long INF = 1e18;
static const long long mo = 1e9+7;

using namespace std;

class JanuszTheBusinessman
{
public:
    int makeGuestsReturn (vector <int> arrv, vector <int> dept)
    {
        ll N = arrv.size();
        ll ans = 0;

        ll cur = 0;
        while (1) {
            cout << cur << endl;
            ll firstDept = INF; // curより後に到着する中で、一番早く出発する人の出発時間を計算
            rep (i, N) 
                if (arrv[i] > cur) 
                    chmin(firstDept, dept[i]);
            if (firstDept == INF) 
                break;

            rep (i, N) 
                if (arrv[i] <= firstDept) 
                    chmax(cur, dept[i]);
            ans++;
        }
        cout << cur << endl;

        return ans;
    }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	JanuszTheBusinessman *obj;
	int answer;
	obj = new JanuszTheBusinessman();
	clock_t startTime = clock();
	answer = obj->makeGuestsReturn(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <int> p0;
	vector <int> p1;
	int p2;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {2,10,6};
	p1 = {6,11,9};
	p2 = 2;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {2,10,23,34,45,123,1};
	p1 = {25,12,40,50,48,187,365};
	p2 = 1;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {8,12,20,30,54,54,68,75};
	p1 = {13,31,30,53,55,70,80,76};
	p2 = 3;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {124,328,135,234,347,124,39,99,116,148};
	p1 = {237,335,146,246,353,213,197,215,334,223};
	p2 = 2;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {154,1,340,111,92,237,170,113,241,91,228,134,191,86,59,115,277,328,12,6};
	p1 = {159,4,341,118,101,244,177,123,244,96,231,136,193,95,64,118,282,330,17,13};
	p2 = 14;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	disabled = false;
	p0 = {1, 2, 3, 4, 5, 6, 7};
	p1 = {2, 3, 365, 5, 6, 7, 8};
	p2 = 2;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, true, p2) ) && all_right;
    
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Janusz owns a hotel.
// He has already received some reservations for the upcoming year.
// The days in the year are numbered 1 through 365.
// For each valid i, there is a guest who will arrive on day arrivals[i] and depart on day departures[i].
// 
// Janusz can give some guests a special promotion.
// Any guest that gets the special promotion will leave a good review.
// Additionally, all guests that meet a guest with promotion will also leave a good review.
// (Here we assume that two guests meet if and only if they are in the hotel on the same day, including the situation when one of them departs on the same day the other one arrives.)
// 
// Janusz wants to make sure that all his guests leave good reviews.
// You are given the vector <int>s arrivals and departures.
// Return the smallest possible number of special promotions sufficient to make sure that all guests leave good reviews.
// 
// 
// DEFINITION
// Class:JanuszTheBusinessman
// Method:makeGuestsReturn
// Parameters:vector <int>, vector <int>
// Returns:int
// Method signature:int makeGuestsReturn(vector <int> arrivals, vector <int> departures)
// 
// 
// CONSTRAINTS
// -arrivals and departures will have the same number of elements.
// -arrivals will have between 2 and 50 elements, inclusive.
// -Each element of arrivals and departures will be between 1 and 365, inclusive.
// -For each valid i arrivals[i] will be less than departures[i].
// 
// 
// EXAMPLES
// 
// 0)
// {2, 10, 6}	
// {6, 11, 9}
// 
// Returns: 2
// 
// One promotion is not enough.
// One optimal solution is to give promotions to the guest who arrives on day 2 and to the guest who arrives on day 10.
// The third guest will meet the first guest on day 6.
// 
// 1)
// {2, 10, 23, 34, 45, 123, 1}
// {25, 12, 40, 50, 48, 187, 365}
// 
// Returns: 1
// 
// One guest is going to stay for the whole season so Janusz can give the promotion only to him.
// 
// 2)
// {8, 12, 20, 30, 54, 54, 68, 75}
// {13, 31, 30, 53, 55, 70, 80, 76}
// 
// Returns: 3
// 
// 
// 
// 3)
// {124, 328, 135, 234, 347, 124, 39, 99, 116, 148}
// {237, 335, 146, 246, 353, 213, 197, 215, 334, 223}
// 
// Returns: 2
// 
// 
// 
// 4)
// {154, 1, 340, 111, 92, 237, 170, 113, 241, 91, 228, 134, 191, 86, 59, 115, 277, 328, 12, 6}
// {159, 4, 341, 118, 101, 244, 177, 123, 244, 96, 231, 136, 193, 95, 64, 118, 282, 330, 17, 13}
// 
// Returns: 14
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
