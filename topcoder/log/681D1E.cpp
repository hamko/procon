#include <bits/stdc++.h>
using namespace std;

#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)
#define pb push_back
#define all(x) (x).begin(), (x).end()
template<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }
template<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }
template <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << "(" << v.first << ", " << v.second << ")"; return o; }
template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { if (!v.empty()) { o << '['; copy(v.begin(), v.end(), ostream_iterator<T>(o, ", ")); o << "\b\b]"; } return o; }
using ll = long long; using ld = long double; using vll = vector<ll>; using vld = vector<ld>;
typedef pair<ll, ll> P;

static const double EPS = 1e-14;
static const long long INF = 1e18;
#define MAX_N 100005

// 整数二分探索
// O(log(range))
// f: 単調増加関数. 000111, 111111, 000000を許容する（11110000で探索したい場合は、自分でfを反転すること）
// 閉区間[rl, rr]から単調関数fを満たす最小の数を返す。
// 全て0ならrr+1を返す！
ll BinarySearch(ll rl, ll rr, function<bool(ll)> f) { 
    ll lo = rl-1, ro = rr+1;
    while (ro - lo != 1) {
        ll m = (lo + ro) / 2; 
        (m!=rl-1&&f(m))?ro=m:lo=m; 
    }
    return ro;
}

class FleetFunding {
    public:
        int maxShips(int m, vector <int> k, vector <int> a, vector <int> b) {
            vector<P> b_(b.size()); rep(i, b.size()) { b_[i].first = b[i]; b_[i].second = i; } sort(all(b_));
            vll index(b.size()); rep(i, b.size()) index[i] = b_[i].second;
            vector<int> k_org = k;

            auto f = [&](ll x){
                k = k_org;
                rep(i, m) {
                    ll s = 0;
                    rep(j_, b.size()) {
                        ll j = index[j_];
                        if (a[j] <= i + 1 && i + 1 <= b[j]) {
                            ll tmp = min<ll>(x - s, k[j]);
                            s += tmp; k[j] -= tmp;
                            if (s >= x) 
                                break;
                        }
                    }
                    if (s < x) 
                        return true;
                }
                return false;
            };

            return BinarySearch(0, INF, f) - 1;
        }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, vector <int> p2, vector <int> p3, bool hasAnswer, int p4) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p3.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p3[i];
	}
	cout << "}";
	cout << "]" << endl;
	FleetFunding *obj;
	int answer;
	obj = new FleetFunding();
	clock_t startTime = clock();
	answer = obj->maxShips(p0, p1, p2, p3);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p4 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p4;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	int p0;
	vector <int> p1;
	vector <int> p2;
	vector <int> p3;
	int p4;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 3;
	p1 = {2,2,2};
	p2 = {1,2,1};
	p3 = {3,3,2};
	p4 = 2;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 1;
	p1 = {10,9,8,7,6,5,4,3,2,1};
	p2 = {1,1,1,1,1,1,1,1,1,1};
	p3 = {1,1,1,1,1,1,1,1,1,1};
	p4 = 55;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 10;
	p1 = {2,4,6,8,10,1,3,5,7,9};
	p2 = {1,2,3,4,5,6,7,8,9,10};
	p3 = {1,2,3,4,5,6,7,8,9,10};
	p4 = 1;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 84457;
	p1 = {374778,169109,529984,498638,29462,465769,29285,394948,307944,459189,349316,766627,686851,404285,850199,359378,3014,248257,558856,27393,32370,574862,337134,965567,32223,935678,389898,973497,990575,483190,122899,857994,991217,149619,415870};
	p2 = {92,4997,11,28545,933,210,2,124,114,4513,32959,1,57,17,13,133,1843,41851,3,9296,9757,28,3,769,10,11102,683,6173,11821,3982,214,2,4304,439,1998};
	p3 = {81034,54474,70239,79597,47317,82938,83883,74652,84033,84422,84456,84457,81095,83743,79210,84255,84455,45596,84456,82959,67062,80330,44090,84445,84454,84450,45931,77190,83025,83567,83639,84333,83355,70982,84456};
	p4 = 186;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = 2;
	p1 = {1000000,1000000,1000000,1000000,1000000};
	p2 = {1,1,1,2,2};
	p3 = {1,1,2,2,2};
	p4 = 2500000;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// George is in charge of building a fleet of spaceships.
// Each spaceship consists of m different parts, labeled from 1 to m.
// 
// 
// 
// George has no parts at the moment but he has an unlimited supply of money.
// There are n workshops that can produce the parts he needs.
// The workshops can be described by the vector <int>s k, a, and b.
// For each valid i, there is a workshop that has the following limits:
// 
// The workshop has a limited amount of resources and therefore it can produce at most k[i] parts in total.
// The workshop can only produce parts with numbers between a[i] and b[i], inclusive.
// 
// Note that each workshop can create multiple copies of the same part, as long as the total number of parts produced by that workshop doesn't exceed k[i].
// 
// 
// 
// Given these constraints, determine the maximum number of spaceships George can build.
// 
// 
// DEFINITION
// Class:FleetFunding
// Method:maxShips
// Parameters:int, vector <int>, vector <int>, vector <int>
// Returns:int
// Method signature:int maxShips(int m, vector <int> k, vector <int> a, vector <int> b)
// 
// 
// CONSTRAINTS
// -n will be between 1 and 50, inclusive.
// -m will be between 1 and 10^5, inclusive.
// -k,a,b will have exactly n elements each.
// -Each element of k will be between 1 and 10^6, inclusive.
// -Each element of a,b will be between 1 and m, inclusive.
// -For each integer i from 0 to n-1, inclusive, a[i] will be less than or equal to b[i].
// 
// 
// EXAMPLES
// 
// 0)
// 3
// {2,2,2}
// {1,2,1}
// {3,3,2}
// 
// Returns: 2
// 
// In this test case, each spaceship requires parts 1, 2, and 3.
// We have the following workshops:
// 
// Workshop 0 can produce at most 2 parts, each with a label between 1 and 3, inclusive.
// Workshop 1 can produce at most 2 parts, each with a label between 2 and 3, inclusive.
// Workshop 2 can produce at most 2 parts, each with a label between 1 and 2, inclusive.
// 
// We can build two complete spaceships.
// One possible solution:
// 
// Workshop 0 will produce a part with label 1 and a part with label 3.
// Workshop 1 will produce a part with label 2 and a part with label 3.
// Workshop 2 will produce a part with label 1 and a part with label 2.
// 
// Another possible solution:
// 
// Workshop 0 will produce two parts with label 2.
// Workshop 1 will produce two parts with label 3.
// Workshop 2 will produce two parts with label 1.
// 
// 
// 1)
// 1
// {10,9,8,7,6,5,4,3,2,1}
// {1,1,1,1,1,1,1,1,1,1}
// {1,1,1,1,1,1,1,1,1,1}
// 
// Returns: 55
// 
// 
// 
// 2)
// 10
// {2,4,6,8,10,1,3,5,7,9}
// {1,2,3,4,5,6,7,8,9,10}
// {1,2,3,4,5,6,7,8,9,10}
// 
// Returns: 1
// 
// Here we can buy a lot of different parts.
// The bottleneck is part number 6.
// This can only be produced by workshop 5, and this workshop can only build us a single copy of this part.
// Thus, we can only build a single spaceship.
// 
// 3)
// 84457
// {374778,169109,529984,498638,29462,465769,29285,394948,307944,459189,
// 349316,766627,686851,404285,850199,359378,3014,248257,558856,27393,32370,
// 574862,337134,965567,32223,935678,389898,973497,990575,483190,122899,
// 857994,991217,149619,415870}
// {92,4997,11,28545,933,210,2,124,114,4513,32959,1,57,17,13,133,1843,41851,
// 3,9296,9757,28,3,769,10,11102,683,6173,11821,3982,214,2,4304,439,1998}
// {81034,54474,70239,79597,47317,82938,83883,74652,84033,84422,84456,84457,
// 81095,83743,79210,84255,84455,45596,84456,82959,67062,80330,44090,84445,
// 84454,84450,45931,77190,83025,83567,83639,84333,83355,70982,84456}
// 
// Returns: 186
// 
// 
// 
// 4)
// 2
// {1000000,1000000,1000000,1000000,1000000}
// {1,1,1,2,2}
// {1,1,2,2,2}
// 
// Returns: 2500000
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
