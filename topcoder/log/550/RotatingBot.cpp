#include <bits/stdc++.h>
using namespace std;

#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define mt make_tuple
template<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }
template<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

using ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; 
using vi = vector<int>; using vvi = vector<vi>;
using P = pair<ll, ll>;

template <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << "(" << v.first << ", " << v.second << ")"; return o; }
template<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};
template<class Ch, class Tr, class Tuple, size_t... Is>
void print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? "" : ", ") << get<Is>(t)), 0)...}; }
template<class Ch, class Tr, class... Args> 
auto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << "("; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << ")"; }
ostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << " "; cout << endl; } return o; }
template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? ", " : ""); o << "]";  return o; }
template <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? ", " : ""); o << "]";  return o; }
template <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? ", " : ""); o << "]";  return o; }
template <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << "]";  return o; }

static const double EPS = 1e-14;
static const long long INF = 1e18;
static const long long mo = 1e9+7;

class RotatingBot {
    public:
        int minArea(vector <int> m) {
            ll x = 0, y = 0;
            vll dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};

            set<P> memo;
            vll lim(4, INF); // lim[2] < x < lim[0], lim[3] < y < lim[1]
            memo.insert(P(x, y));
            rep(i, m.size()) {
                ll d = i % 4;
                rep(j, m[i]) {
                    x += dx[d];
                    y += dy[d];
                    if (memo.count(P(x, y))) {
                        cout << "already" << endl;
                        return -1;
                    }
                    memo.insert(P(x, y));
                }
                if (i != m.size() - 1 && !memo.count(P(x+dx[d], y+dy[d]))) { // limit or bad
                    if (lim[d] == INF) {
                        lim[d] = (d % 2 ? y + dy[d] : x + dx[d]);
                    } else {
                        if (lim[d] != (d % 2 ? y + dy[d] : x + dx[d])) {
                            cout << "empty rotate" << endl;
                            return -1;
                        }
                    }
                }
            }
            ll mx = +INF; 
            ll Mx = -INF; 
            ll my = +INF; 
            ll My = -INF; 
            for (auto p : memo) {
                if (lim[0] != INF && lim[0] <= p.fi) { cout << "b" << endl; return -1; } 
                if (lim[1] != INF && lim[1] <= p.se) { cout << "c" << endl; return -1; }
                if (lim[2] != INF && lim[2] >= p.fi) { cout << "a" << endl; return -1; }
                if (lim[3] != INF && lim[3] >= p.se) { cout << "d" << endl; return -1; }
                chmin(mx, p.fi);
                chmax(Mx, p.fi);
                chmin(my, p.se);
                chmax(My, p.se);
            }

            return (Mx - mx + 1) * (My - my + 1);
        }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	RotatingBot *obj;
	int answer;
	obj = new RotatingBot();
	clock_t startTime = clock();
	answer = obj->minArea(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <int> p0;
	int p1;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {15};
	p1 = 16;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {3,10};
	p1 = 44;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {1,1,1,1};
	p1 = -1;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {9,5,11,10,11,4,10};
	p1 = 132;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {12,1,27,14,27,12,26,11,25,10,24,9,23,8,22,7,21,6,20,5,19,4,18,3,17,2,16,1,15};
	p1 = 420;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = {8,6,6,1};
	p1 = -1;
	all_right = (disabled || KawigiEdit_RunTest(5, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 6 -----
	disabled = false;
	p0 = {8,6,6};
	p1 = 63;
	all_right = (disabled || KawigiEdit_RunTest(6, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 7 -----
	disabled = false;
	p0 = {5,4,5,3,3};
	p1 = 30;
	all_right = (disabled || KawigiEdit_RunTest(7, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 8 -----
	disabled = false;
	p0 = {1,2,3,4,5};
	p1 = -1;
	all_right = (disabled || KawigiEdit_RunTest(8, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// NOTE: This problem statement contains images that may not display properly if viewed outside of the applet.
// 
// We had a rectangular grid that consisted of W x H square cells.
// We placed a robot on one of the cells.
// The robot then followed the rules given below.
// 
// 
// Initially, the robot is facing east.
// The robot moves in steps. In each step it moves to the adjacent cell in the direction it currently faces.
// The robot may not leave the grid.
// The robot may not visit the same cell twice. (This also means that it may not reenter the starting cell.)
// If a step forward does not cause the robot to break the above rules, the robot takes the step.
// Otherwise, the robot rotates 90 degrees to the left (counter-clockwise) and checks whether a step forward still breaks the above rules.
//   If not, the robot takes the step and continues executing this program (still rotated in the new direction).
// If the rotation left did not help, the robot terminates the execution of this program.
// We can also terminate the execution of the program manually, at any moment.
// 
// For example, the following seven images show a series of moves made by the robot in a 12 x 11 board:
// 
// 
// We forgot the dimensions of the grid and the original (x,y) coordinates of the cell on which the robot was originally placed, but we do remember its movement. You are given a vector <int> moves. This sequence of positive integers shall be interpreted as follows:
// The robot performed moves[0] steps eastwards, turned left, performed moves[1] steps northwards, turned left, and so on.
// After performing the last sequence of steps, the robot stopped. (Either it detected that it should terminate, or we stopped it manually.) We are not sure if the sequence of moves is valid. If the sequence of moves is impossible, return -1. Else, return the minimum area of a grid in which the sequence of moves is possible.
// (I.e., the return value is the smallest possible value of the product of W and H.).
// 
// DEFINITION
// Class:RotatingBot
// Method:minArea
// Parameters:vector <int>
// Returns:int
// Method signature:int minArea(vector <int> moves)
// 
// 
// CONSTRAINTS
// -moves will contain between 1 and 50 elements, inclusive.
// -Each element of moves will be between 1 and 50, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {15}
// 
// Returns: 16
// 
// The smallest valid board is a 16x1 board, with the robot starting on the west end of the board.
// 
// 1)
// {3,10}
// 
// Returns: 44
// 
// The smallest solution is to place the robot into the southwest corner of a 4 x 11 board.
// 
// 2)
// {1,1,1,1}
// 
// Returns: -1
// 
// This sequence of moves is not possible because the robot would return to its initial location which is forbidden.
// 
// 3)
// {9,5,11,10,11,4,10}
// 
// Returns: 132
// 
// These moves match the image from the problem statement.
// 
// 4)
// {12,1,27,14,27,12,26,11,25,10,24,9,23,8,22,7,21,6,20,5,19,4,18,3,17,2,16,1,15}
// 
// Returns: 420
// 
// 5)
// {8,6,6,1}
// 
// Returns: -1
// 
// 
// 
// 6)
// {8,6,6}
// 
// Returns: 63
// 
// 
// 
// 7)
// {5,4,5,3,3}
// 
// Returns: 30
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
