#include <bits/stdc++.h>
using namespace std;

#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define mt make_tuple
template<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }
template<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

using ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; 
using vi = vector<int>; using vvi = vector<vi>;
using P = pair<ll, ll>;

template <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << "(" << v.first << ", " << v.second << ")"; return o; }
template<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};
template<class Ch, class Tr, class Tuple, size_t... Is>
void print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? "" : ", ") << get<Is>(t)), 0)...}; }
template<class Ch, class Tr, class... Args> 
auto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << "("; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << ")"; }
ostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << " "; cout << endl; } return o; }
template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? ", " : ""); o << "]";  return o; }
template <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? ", " : ""); o << "]";  return o; }
template <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? ", " : ""); o << "]";  return o; }
template <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << "]";  return o; }

static const double EPS = 1e-14;
static const long long INF = 1e18;
static const long long mo = 1e9+7;

class CheckerExpansion {
    public:
        vector <string> resultAfter(long long t, long long j0, long long i0, int nj, int ni) {
            vector<string> ret(ni, string(nj, '.'));
            vector<string> s0 = {
                "A.B.", 
                ".B..", 
            };
            function<char(ll, ll, ll)> f = [&](ll n, ll i, ll j) -> char { 
                if (!(i < (1ll << (n + 1)) && j < (1ll << (n + 2)))) {
                    return f(n+1, i, j);
                }
                if (n == 0) {
                    return s0[i][j];
                }
                ll si = i >> n; // 0 or 1
                ll sj = j >> n; // 0, 1, 2, 3
                if (si == 1 && (sj == 0 || sj == 3)) {
                    return '.';
                } else if (si == 0 && (sj == 0 || sj == 1)) {
                    return f(n - 1, i, j);
                } else if (si == 0 && (sj == 2 || sj == 3)) {
                    return f(n - 1, i, j - (1ll << (n + 1)));
                } else {
                    return f(n - 1, i - (1ll << n), j - (1ll << n));
                }
            };
            rep(i, ni) rep(j, nj) {
                if (i0 + i + j0 + j <= 2ll * (t - 1)) {
                    ret[i][j] = f(0, i0+i, j0+j);
                }
            }
            reverse(all(ret));

            return ret;
        }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, long long p0, long long p1, long long p2, int p3, int p4, bool hasAnswer, vector <string> p5) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3 << "," << p4;
	cout << "]" << endl;
	CheckerExpansion *obj;
	vector <string> answer;
	obj = new CheckerExpansion();
	clock_t startTime = clock();
	answer = obj->resultAfter(p0, p1, p2, p3, p4);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p5.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << "\"" << p5[i] << "\"";
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << answer[i] << "\"";
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p5.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p5[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	long long p0;
	long long p1;
	long long p2;
	int p3;
	int p4;
	vector <string> p5;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 1ll;
	p1 = 0ll;
	p2 = 0ll;
	p3 = 4;
	p4 = 4;
	p5 = {"....","....","....","A..."};
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, true, p5) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
 
    // ----- test 0 -----
	disabled = false;
	p0 = 2ll;
	p1 = 0ll;
	p2 = 0ll;
	p3 = 4;
	p4 = 4;
	p5 = {"....","....",".B..","A.B."};
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, true, p5) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 5ll;
	p1 = 4ll;
	p2 = 1ll;
	p3 = 3;
	p4 = 4;
	p5 = {"A..","...","B..",".B."};
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, true, p5) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 1024ll;
	p1 = 1525ll;
	p2 = 512ll;
	p3 = 20;
	p4 = 2;
	p5 = {"B...B...B...........",".B.A.B.A.B.........."};
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, true, p5) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 53ll;
	p1 = 85ll;
	p2 = 6ll;
	p3 = 5;
	p4 = 14;
	p5 = {".....",".....","B....",".B.A.",".....",".....",".....",".....",".....",".....","B....",".B...","..B..",".A.B."};
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, true, p5) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Alice and Bob are playing a game on an infinite grid. The grid is initially empty. Alice and Bob each have an infinite supply of checkers. Alice's checkers are red, Bob's are blue. In the first turn, Alice places one of her red checkers into the cell (0,0). The game continues by Bob and Alice taking alternate turns. In each turn, the current player places their checkers into some empty cells. The player must always add all the checkers that can be added in their turn by repeatedly applying the following rules:
// 
// If cell (x-1,y-1) contains a checker of the other player and cell (x-2,y) is empty, add your checker into the cell (x,y).
// If cell (x-2,y) contains a checker of the other player and cell (x-1,y-1) is empty, add your checker into the cell (x,y).
// 
// Bob has asked you to simulate the game so that he can understand it better. You are given long longs
// t, x0 and y0 and ints w and h. Return a vector <string> containing h elements of w characters each. The j-th character of the i-th element of your return value will represent the contents of cell at x=x0+j and y=y0+h-i-1 after t turns. The character representing a particular cell should be 'A' (quotes for clarity) if it contains one of Alice's checkers, 'B' if it contains one of Bob's checkers and '.' if it is empty. 
// 
// DEFINITION
// Class:CheckerExpansion
// Method:resultAfter
// Parameters:long long, long long, long long, int, int
// Returns:vector <string>
// Method signature:vector <string> resultAfter(long long t, long long x0, long long y0, int w, int h)
// 
// 
// CONSTRAINTS
// -t will be between 1 and 1000000000000 (10^12), inclusive.
// -x0 and y0 will each be between 0 and 1000000000000 (10^12), inclusive.
// -w and h will each be between 1 and 50, inclusive. 
// 
// 
// EXAMPLES
// 
// 0)
// 1
// 0
// 0
// 4
// 4
// 
// Returns: {"....", "....", "....", "A..." }
// 
// This is the initial turn.
// 
// 1)
// 5
// 4
// 1
// 3
// 4
// 
// Returns: {"A..", "...", "B..", ".B." }
// 
// The checker that appears at the top row of this rectangle was placed by Alice just at the fifth turn.
// 
// 2)
// 1024
// 1525
// 512
// 20
// 2
// 
// Returns: {"B...B...B...........", ".B.A.B.A.B.........." }
// 
// 
// 
// 3)
// 53
// 85
// 6
// 5
// 14
// 
// Returns: {".....", ".....", "B....", ".B.A.", ".....", ".....", ".....", ".....", ".....", ".....", "B....", ".B...", "..B..", ".A.B." }
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
