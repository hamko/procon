#include <bits/stdc++.h>
using namespace std;

#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)
#define pb push_back
#define all(x) (x).begin(), (x).end()
template<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }
template<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }
template <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << "(" << v.first << ", " << v.second << ")"; return o; }
template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { if (!v.empty()) { o << '['; copy(v.begin(), v.end(), ostream_iterator<T>(o, ", ")); o << "\b\b]"; } return o; }
using ll = long long; using ld = long double; using vll = vector<ll>; using vld = vector<ld>;
typedef pair<ll, ll> P;

static const double EPS = 1e-14;
static const long long INF = 1e18;
#define MAX_N 100005

class SmilesTheFriendshipUnicorn {
    public:
        string hasFriendshipChain(int N, vector <int> A, vector <int> B) {
            vector<vector<ll>> g(N);
            rep(i, A.size()) { g[A[i]].pb(B[i]); g[B[i]].pb(A[i]); }

            bool ret = 0;
            rep(i, N) { // start from i
                vll r;
                function<bool(ll)> f = [&](ll curr) {
                    r.pb(curr);
                    if (r.size() >= 5) 
                        return true;
                    bool ret = 0;
                    rep(j, g[curr].size()) 
                        if (find(all(r), g[curr][j]) == r.end())
                            ret |= f(g[curr][j]);
                    r.pop_back();
                    return ret;
                };
                ret |= f(i);
            }
            return (ret ? "Yay!" : ":(");
        }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, vector <int> p2, bool hasAnswer, string p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}";
	cout << "]" << endl;
	SmilesTheFriendshipUnicorn *obj;
	string answer;
	obj = new SmilesTheFriendshipUnicorn();
	clock_t startTime = clock();
	answer = obj->hasFriendshipChain(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p3 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	int p0;
	vector <int> p1;
	vector <int> p2;
	string p3;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 5;
	p1 = {0,1,2,3};
	p2 = {1,2,3,4};
	p3 = "Yay!";
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 5;
	p1 = {0,1,2,3,1};
	p2 = {1,2,3,0,4};
	p3 = "Yay!";
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 6;
	p1 = {0,0,0,0,0};
	p2 = {1,2,3,4,5};
	p3 = ":(";
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 8;
	p1 = {1,3,4,3,4,3,0,2};
	p2 = {7,7,7,4,6,5,4,7};
	p3 = "Yay!";
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = 7;
	p1 = {0,1,1,5,4,5};
	p2 = {5,2,3,6,1,1};
	p3 = ":(";
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = 42;
	p1 = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41};
	p2 = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,0};
	p3 = "Yay!";
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 6 -----
	disabled = false;
	p0 = 5;
	p1 = {0, 0, 2, 4, 0, 0};
	p2 = {3, 1, 3, 1, 4, 2};
	p3 = "Yey!";
	all_right = (disabled || KawigiEdit_RunTest(6, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Smiles the Friendship Unicorn lives in the Friendship Kingdom. There are N people in the Friendship Kingdom, numbered from 0 to N-1. Some of them are friends with each other: you are given these pairs in the vector <int> A and the vector <int> B. For each valid i, the person numbered A[i] is friends with the person numbered B[i]. Friendship is two-way, so the person numbered B[i] is also friends with the person numbered A[i]. For every group containing between 1 and N-1 people (inclusive), at least one person in the group is friends with someone outside the group.
// 
// Smiles would like to know whether there exists a friendship chain. A friendship chain is a sequence of 5 distinct people A, B, C, D, and E such that:
// 
// A is friends with B.
// B is friends with C.
// C is friends with D.
// D is friends with E.
// 
// (In the language of graph theory: a friendship chain is a simple path of length 4.)
// 
// If a friendship chain exists, output "Yay!". Otherwise, output ":(". (All quotes are for clarity only.)
// 
// DEFINITION
// Class:SmilesTheFriendshipUnicorn
// Method:hasFriendshipChain
// Parameters:int, vector <int>, vector <int>
// Returns:string
// Method signature:string hasFriendshipChain(int N, vector <int> A, vector <int> B)
// 
// 
// CONSTRAINTS
// -N will be between 5 and 2000, inclusive.
// -A will contain between 1 and 2000 elements, inclusive.
// -A and B will contain the same number of elements.
// -Each element of A and B will be between 0 and N-1, inclusive.
// -No one will be friends with themselves.
// -The same friendship will not be given twice in the input.
// -For every group containing between 1 and N-1 people (inclusive), at least one person in the group is friends with someone outside the group.
// 
// 
// EXAMPLES
// 
// 0)
// 5
// {0, 1, 2, 3}
// {1, 2, 3, 4}
// 
// Returns: "Yay!"
// 
// A friendship chain is formed by:
// 
// Person 0
// Person 1
// Person 2
// Person 3
// Person 4
// 
// in that order. (The reverse order 4-3-2-1-0 is also a valid friendship chain.)
// 
// 1)
// 5
// {0, 1, 2, 3, 1}
// {1, 2, 3, 0, 4}
// 
// Returns: "Yay!"
// 
// One example of a valid friendship chain is:
// 
// Person 4
// Person 1
// Person 2
// Person 3
// Person 0
// 
// 
// 2)
// 6
// {0, 0, 0, 0, 0}
// {1, 2, 3, 4, 5}
// 
// Returns: ":("
// 
// 
// 
// 3)
// 8
// {1, 3, 4, 3, 4, 3, 0, 2}
// {7, 7, 7, 4, 6, 5, 4, 7}
// 
// Returns: "Yay!"
// 
// 
// 
// 4)
// 7
// {0, 1, 1, 5, 4, 5}
// {5, 2, 3, 6, 1, 1}
// 
// Returns: ":("
// 
// 
// 
// 5)
// 42
// {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41}
// 
// {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 0}
// 
// Returns: "Yay!"
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
