// for i in `seq 3600`; do sleep 1; dot -T png typical.dot -o typical.png; done

digraph graph_name {
    graph [
        //    layout = dot
        layout = fdp
    ];
    node [
        colorscheme = "rdylgn11";
        style = "solid,filled";
        fontsize = 16;
        fontname = "Migu 1M";
        height = 0.6;
        width = 1.2;
    ];

    問題 [shape=doublecircle,fontsize=60];

    問題 -> グラフ;
    問題 -> 数え上げ;
    問題 -> 列;
    問題 -> 最小化;
    問題 -> k番目;
    問題 -> 辞書順最小化;
    問題 -> クエリ;
    問題 -> 木;
    問題 -> 多次元;
    問題 -> "YES/NO";
    問題 -> XOR;
    問題 -> 構築;
    問題 -> ゲーム;
    問題 -> 文字列;
    問題 -> マンハッタン距離;
    問題 -> "約数, gcd";
    問題 -> 共通;

    k番目 -> "i番目が満たすかを二分探索";

    列 -> 累積和を折れ線として見る;

    共通 -> 問題制約を減らして解いてみる;
    共通 -> "小さいものから見ていく（）";
    小さいものから見ていく -> とりまソート [label="順序に関係ない"];
    共通 -> 区間;
    共通 -> 対称;
    共通 -> 環状;
    共通 -> 被覆 -> "後ろから見て塗り剥がして?を埋めておく";
    共通 -> 固定するなら真ん中 [label="DoFが3以上で連結性が限定"]; 
    共通 -> 操作を逆順に見る;
    共通 -> コスト;
    共通 -> "ちょうど1回操作";

    "ちょうど1回操作" -> "2回以上の任意のループを作れる"

    コスト -> 線形コスト -> 独立;
    コスト -> 指数コスト -> 貪欲;

    対象 -> 平均値と中央値が一致;

    環状 -> 環状を切る部分を全探索;
    環状 -> 環状を切って始めを固定;

    区間 -> 終端でソート;
    区間 -> 始点を固定;
    始点を固定 -> 終点に対して単調 -> 二分探索;
    始点を固定 -> 終点の境界位置が始点に対して単調 -> しゃくとり;
    

    木 -> "木DP";
    木 -> "全方位DP" [label="全てのノードが全状態に依存する"];
    木 -> "重心";
    木 -> "中心";
    木 -> "直径";
    木 -> "同型";
    木 -> "部分木" -> オイラーツアー;
    木 -> パス -> "根付き木にして、パスは(lca-a)+(lca-b)-2(r-lca)";

    "約数, gcd" -> "約数全列挙" -> "sum_g n/gはO(n log n)";

    グラフ -> 辺に着目;
    グラフ -> "小さい制約(5歩で、10回で）" [label="半分全列挙"];
    グラフ -> "最短経路DAG";
    グラフ -> "最短経路として使われうる辺は最短経路問題で";

    "マンハッタン距離" -> "45度回転";
    "マンハッタン距離" -> "xy独立";
    "マンハッタン距離" -> "長さ1の移動に分解";

    構築 -> "連立方程式の解の一例";
    "連立方程式の解の一例" -> "最短距離問題双対（牛ゲー）" [label="不等式"];
    "連立方程式の解の一例" -> "DFSで矛盾検知" [label="等式"];
    "連立方程式の解の一例" -> "重み付きUnion Find" [label="等式"];
    構築 -> "小制約の全探索ができる" -> "辞書順最小の解を出して法則を見出す";
    構築 -> SAT;
    構築 -> 構築すべきグラフ;
    構築 -> 構築すべき盤面;
    構築 -> "満たす解を1つ想定してそこからの操作ができるかを考える";
    構築 -> "乱択";
    構築すべきグラフ -> ウニグラフ;
    構築すべきグラフ -> ウニのカップリンググラフ;
    構築すべきグラフ -> 線グラフ;
    構築すべきグラフ -> 木;
    構築すべきグラフ -> クリーク;
    構築すべきグラフ -> 二部グラフ;
    構築すべきグラフ -> 二部グラフの両端がいくつか連結;
    構築すべきグラフ -> ファンクショナルグラフ;
    構築すべき盤面 -> カギ型 [label="連結性"];
    構築すべき盤面 -> 左右をとりあえず白黒に分ける;
    構築すべき盤面 -> "L字型";
    構築すべき盤面 -> "列固定";


    数え上げ -> 二分探索;
    数え上げ -> DP;
    数え上げ -> "X以上の関数を作る" [label="ちょうどX"];
    数え上げ -> "X以下の関数を作る" [label="ちょうどX"];
    数え上げ -> "包除原理";
    数え上げ -> "高速ゼータ・メビウス変換";
    数え上げ -> 種類の数え上げ -> 直前に出てきたところをメモ; 
    数え上げ -> 区間の数え上げ -> "count_{l, r} f(l) <= f(r)に落とす";
    
    回文 -> "文字列長が短い順にDP";

    

    多次元 -> xy独立;
    多次元 -> 一次元固定;

    クエリ -> オフラインクエリ;
    クエリ -> クエリスキップ [label="初期状態の構造が簡単"];
    クエリ -> オンラインクエリ;
    クエリ -> 木のクエリ;
    クエリ -> 範囲クエリ;
    クエリ -> クエリ平方分割;
    オフラインクエリ -> "Decomposable searching problem";
    オフラインクエリ -> クエリソート;
    クエリ平方分割 -> 木のクエリ平方分割;
    クエリソート -> "Mo" [label="尺取りができる列クエリ"];
    木のクエリ -> "HL分解" [label="モノイド"];
    木のクエリ -> "オイラーツアー" [label="群"];
    木のクエリ -> "LCA";
    木のクエリ ->  木の切断;
    木の切断 -> "Link-Cut Tree";
    オンラインクエリ -> 平方分割;
    オンラインクエリ -> 連結行列のセグ木;
    範囲クエリ->"imos的操作で点の操作に言い換える";


    XOR -> 桁ごと固定;
    XOR -> "Trie木" [label="最大化？"];
    XOR -> "ANDと共にGF(2)" -> "行列累乗" [label="方程式が大量にある"];
    XOR -> "a xor a = 0";
    XOR -> "01が立っている様子を思い浮かべる（XOR<=SUM）";

    ゲーム -> "WL-Algorithm";
    ゲーム -> "Grundy Number";
    ゲーム -> "アドホック";
    ゲーム -> "後ろから確定";
    ゲーム -> "猿真似";

    "Grundy Number" -> "分裂";

    最小化 -> DP;
    DP -> "巨視的に見てデータ構造ゲー";
    DP -> "順序を貪欲に決める" [label="順列の自由度が無理そう"];
    最小化 -> 二分探索;
    最小化 -> 最小値全探索;
    最小化 -> "1変数固定";
    最小化 -> フロー [label="大量制約"];
    最小化 -> "Totally monotone minima";
    最小化 -> "回数の最小値の上限が実は有限（2回とか3回とか）";
    数え上げ -> "半分全列挙" [label="小制約"];

    貪欲 -> 最適解を端点に寄せる;

    辞書順最小化 -> "上から貪欲";
    辞書順最小化 -> "最近のものを26分木でまとめていく";
    辞書順最小化 -> "同じ桁なら数字比較と辞書順比較は一致";

    "YES/NO" -> 乱択;
    "YES/NO" -> "大量制約";
    "大量制約" -> "SAT";
    "SAT" -> "2-SAT" [label="制約変数が2個以下"]; 
    "SAT" -> "3-SAT" [label="制約変数が3個以上"]; 
    "2-SAT" -> "Segment Tree SAT" [label="範囲禁止がある"];

    文字列 -> マッチング;
    文字列 -> 一致判定;
    一致判定 -> "ロリハ" [label="1次元"];
    一致判定 -> "ロリハ" [label="2次元"]; 
    一致判定 -> "SA-IS" [label="1次元"]; 
}
